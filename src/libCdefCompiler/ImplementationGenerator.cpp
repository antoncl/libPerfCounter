// Copyright (C) 2015,2016 Anton Lauridsen
//
// This file is part of libPerfCounter.
//
// libPerfCounter is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// libPerfCounter is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with libPerfCounter. If not, see <http://www.gnu.org/licenses/>.

#include "stdafx.h"
#include <fstream>

#include "Configuration.hpp"
#include "ImplementationGenerator.hpp"

namespace lib_perf_counter {

ImplementationGenerator::ImplementationGenerator(const fs::path& sourceFileName) :
	_sourceFileName(sourceFileName) 
{
}

bool ImplementationGenerator::generate(MessageCallback callback, te::DictionaryPtr cdefRoot)
{
	cdefRoot->add(TE_TEXT("SOURCE"), _sourceFileName.string());

	te::ContextPtr context = te::Context::BuildContext();

	Configuration& config = Configuration::get();

	fs::path hppFilePath(config.getHppLocation());
	if (hppFilePath.size() == 0) {
		hppFilePath = _sourceFileName;
		hppFilePath.replace_extension(".hpp");
	}
	cdefRoot->add(TE_TEXT("MANIFEST-HEADER"), hppFilePath.filename().string());

	// Add root dictionary to context
	context->setDictionary(cdefRoot);

	// compile the template
	te::StringScanner reader(_template);
	te::TemplatePtr compiledTemplate = te::Template::parse(reader);

	te::te_converter utfConverter;
	std::string countersImpl = utfConverter.to_bytes(compiledTemplate->render(context));

	// filename of the implementation file
	fs::path countersImplPath(config.getImplLocation());
	if (countersImplPath.size() == 0) {
			countersImplPath = _sourceFileName.parent_path() /
									fs::path(_sourceFileName.stem().string() + "impl" +
									_sourceFileName.extension().string());

			countersImplPath.replace_extension(".hpp");
	}


	std::ofstream countersImplStream;
	countersImplStream.open(countersImplPath.string());
	countersImplStream << countersImpl;
	countersImplStream.close();

	return true;
}

const std::u16string ImplementationGenerator::_template = uR"(
/*
 * This file was automatically generated from {{SOURCE}}
 * Do not check this file into the source control system
 * It should be regenerated every time the code is built
 * Generated by {{APP}}-{{VERSION}} on {{TIME}}
 */
#ifndef __{{LABEL}}_COUNTERSIMPL_HPP_
#define __{{LABEL}}_COUNTERSIMPL_HPP_

#if defined(_WIN32)
#	ifndef _WIN32_WINNT
#		include <SDKDDKVer.h>
#		define _WIN32_WINNT _WIN32_WINNT_WINXP
#	endif // !_WIN32_WINNT

#	define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
#	include <windows.h>
#	include <lmerr.h>
#	include "{{MANIFEST-HEADER}}"
#endif

#include <string>
#include <sstream>
#include <codecvt>
#include <memory>

class AbstractCounter
{
protected:
	AbstractCounter(PPERF_COUNTERSET_INSTANCE instance, ULONG id, PVOID counter)
	{
		ULONG status = PerfSetCounterRefValue({{LABEL}}, instance, id, counter);
		if (status != ERROR_SUCCESS) {
			std::stringstream errorMessage;
			errorMessage << "Error setting reference to counter '" << id << "' " << displayErrorText(status) << "'";
			throw std::exception(errorMessage.str().c_str());
		}
	}

	~AbstractCounter()
	{
	}

	std::string displayErrorText(DWORD dwLastError)
	{
		std::string result;

		HMODULE hModule = NULL; // default to system source
		LPSTR MessageBuffer;
		DWORD dwBufferLength;

		DWORD dwFormatFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM;

		//
		// If dwLastError is in the network range, 
		//  load the message source.
		//

		if (dwLastError >= NERR_BASE && dwLastError <= MAX_NERR) {
			hModule = LoadLibraryEx(TEXT("netmsg.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE);
			if (hModule != NULL)
				dwFormatFlags |= FORMAT_MESSAGE_FROM_HMODULE;
		}

		//
		// Call FormatMessage() to allow for message 
		//  text to be acquired from the system 
		//  or from the supplied module handle.
		//
		if (dwBufferLength = FormatMessageA(
			dwFormatFlags,
			hModule, // module to get message from (NULL == system)
			dwLastError,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default language
			(LPSTR)&MessageBuffer,
			0,
			NULL
			))
		{
			result = std::string(MessageBuffer);
			LocalFree(MessageBuffer);
		}

		//
		// If we loaded a message source, unload it.
		//
		if (hModule != NULL)
			FreeLibrary(hModule);

		return result;
	}
};

class Counter32 : public AbstractCounter
{
public:
	Counter32(PPERF_COUNTERSET_INSTANCE instance, ULONG id) :
		AbstractCounter(instance, id, &_counter)
	{
	}

	~Counter32()
	{
	}

	std::uint32_t& getCounter32()
	{
		return _counter;
	}

private:
	std::uint32_t _counter = 0;
};

class Gauge32 : public AbstractCounter
{
public:
	Gauge32(PPERF_COUNTERSET_INSTANCE instance, ULONG id) :
		AbstractCounter(instance, id, &_counter)
	{
	}

	std::uint32_t& getGauge32()
	{
		return _counter;
	}

	~Gauge32()
	{
	}
private:
	std::uint32_t _counter = 0;
};

class Gauge64 : public AbstractCounter
{
public:
	Gauge64(PPERF_COUNTERSET_INSTANCE instance, ULONG id) :
		AbstractCounter(instance, id, &_counter)
	{
	}

	std::uint64_t& getGauge64()
	{
		return _counter;
	}

	~Gauge64()
	{
	}
private:
	std::uint64_t _counter = 0;
};

class CounterSet
{
public:
	CounterSet(LPGUID instanceId, std::wstring& name)
	{
		_instance = PerfCreateInstance({{LABEL}}, instanceId, name.c_str(), 0);
		if (_instance == nullptr) {
			CounterCleanup();

			std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>> converter;
			std::string nameAsChar = converter.to_bytes(name);

			std::stringstream errorMessage;
			errorMessage << "Error creating an instance of the counterset '" << nameAsChar << "' " << GetLastError();
			throw std::exception(errorMessage.str().c_str());
		}
	}

	~CounterSet()
	{
		PerfDeleteInstance({{LABEL}}, _instance);
	}

	protected:
	PPERF_COUNTERSET_INSTANCE _instance;
};

{{#repeat CounterSets}}
class {{LABEL}}CounterSet : public CounterSet
{
public:
	{{LABEL}}CounterSet(LPGUID instanceId, std::wstring& name) :
		CounterSet(instanceId, name)
	{
		{{#repeat Counters}}
		_{{LABEL}} = std::make_unique<{{SNMP-TYPE}}>(_instance, {{ID}});
		{{/repeat}}
	}

	{{#repeat Counters}}
	std::uint32_t& get{{LABEL}}()
	{
		return _{{LABEL}}->get{{SNMP-TYPE}}();
	}
	{{/repeat}}

	~{{LABEL}}CounterSet()
	{
	}

private:
	{{#repeat Counters}}
	std::unique_ptr<{{SNMP-TYPE}}> _{{LABEL}};
	{{/repeat}}
};
{{/repeat}}

class CounterProvider
{
public:
	CounterProvider()
	{
		ULONG status = CounterInitialize(nullptr, nullptr, nullptr, nullptr);
		if (status != ERROR_SUCCESS) {
			std::stringstream errorMessage;
			errorMessage << "Error initializing performance counters:" << status;
			throw std::exception(errorMessage.str().c_str());
		}
	}

		virtual ~CounterProvider()
	{
		CounterCleanup();
	}
};

class {{LABEL}}CounterProvider : public CounterProvider
{
public:
	{{LABEL}}CounterProvider()
	{
		{{#repeat CounterSets}}
		_{{LABEL}} = std::make_unique<{{LABEL}}CounterSet>(&{{LABEL}}Guid, std::wstring(L"{{NAMESPACE}}"));
		{{/repeat}}
	}

		{{#repeat CounterSets}}
	{{LABEL}}CounterSet& get{{LABEL}}Set()
	{
		if (_{{LABEL}}) {
			return *_{{LABEL}};
		}
		else
			throw std::exception("Access to uninitialized counterset '{{LABEL}}'");
	}
	{{/repeat}}

		~{{LABEL}}CounterProvider()
	{
	}
private:
	{{#repeat CounterSets}}
	std::unique_ptr<{{LABEL}}CounterSet> _{{LABEL}};
	{{/repeat}}
};

#endif // !__{{LABEL}}_COUNTERSIMPL_HPP_
)";

}
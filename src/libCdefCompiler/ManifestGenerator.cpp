// Copyright (C) 2015,2016 Anton Lauridsen
//
// This file is part of libPerfCounter.
//
// libPerfCounter is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// libPerfCounter is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public
// License along with libPerfCounter. If not, see <http://www.gnu.org/licenses/>.

#include "stdafx.h"
#include <iostream>
#include <boost/filesystem.hpp>

#include "ManifestGenerator.hpp"
#include "AstProvider.hpp"
#include "AstCounterSet.hpp"
#include "AstCounter.hpp"
#include "infix_iterator.hpp"
#include "Utilities.hpp"
#include "Configuration.hpp"

namespace lib_perf_counter {

const std::u16string ManifestGenerator::_template = u""
      uR"(<?xml version = "1.0" encoding = "UTF-8" ?>)"
u"\n" uR"(<!-- This file was automatically generated from {{SOURCE}} -->)"
u"\n" uR"(<!-- Do not check this file into the source control system -->)"
u"\n" uR"(<!-- It should be regenerated every time the code is built -->)"
u"\n" uR"(<!-- Generated by {{APP}}-{{VERSION}} on {{TIME}} -->)"
u"\n" uR"(<instrumentationManifest)"
u"\n" uR"(    xmlns = "http://schemas.microsoft.com/win/2004/08/events")"
u"\n" uR"(    xmlns:win = "http://manifests.microsoft.com/win/2004/08/windows/events")"
u"\n" uR"(    xmlns:xs = "http://www.w3.org/2001/XMLSchema">)"
u"\n"
u"\n" uR"(    <instrumentation>)"
u"\n"
u"\n" uR"(        <counters xmlns = "http://schemas.microsoft.com/win/2005/12/counters" schemaVersion = "1.1">)"
u"\n"
u"\n" uR"(            <provider callback = "custom")"
u"\n" uR"(                      applicationIdentity = "{{APPLICATION}}")"
u"\n" uR"(                      providerType = "userMode")"
u"\n" uR"(                      providerGuid = "{{{UUID}}}")"
u"\n" uR"(                      providerName = "{{LABEL}}")"
u"\n" uR"(                      symbol = "{{LABEL}}">)"
                       "{{#REPEAT CounterSets}}"
u"\n" uR"(                <counterSet guid = "{{{UUID}}}")"
u"\n" uR"(                            uri = "{{NAMESPACE}}")"
u"\n" uR"(                            name = "{{NAME}}")"
u"\n" uR"(                            description = "{{DESCRIPTION}}")"
u"\n" uR"(                            symbol = "{{LABEL}}")"
u"\n" uR"(                            instances = "single">)"
                           "{{#REPEAT Counters}}"
u"\n" uR"(                    <counter id = "{{ID}}")"
u"\n" uR"(                             uri = "{{NAMESPACE}}")"
u"\n" uR"(                             name = "{{NAME}}")"
u"\n" uR"(                             description = "{{DESCRIPTION}}")"
u"\n" uR"(                             type = "{{WIN-TYPE}}")"
u"\n" uR"(                             detailLevel = "standard">)"
u"\n" uR"(                        <counterAttributes>)"
u"\n" uR"(                            <counterAttribute name = "reference" />)"
u"\n" uR"(                        </counterAttributes>)"
u"\n" uR"(                    </counter>)"
	                       "{{/REPEAT}}"
u"\n" uR"(                </counterSet>)"
	                    "{{/REPEAT}}"
u"\n" uR"(            </provider>)"
u"\n" uR"(        </counters>)"
u"\n"
u"\n" uR"(    </instrumentation>)"
u"\n"
u"\n" uR"(</instrumentationManifest>)"
;

ManifestGenerator::ManifestGenerator(const fs::path& sourceFileName) :
	_sourceFileName(sourceFileName)
{ }

bool ManifestGenerator::generate(MessageCallback callback, te::DictionaryPtr cdefRoot)
{
	bool result = true;
// the manifest will only work and can only be compiled under windows
// the following code is *very* windows specific
#ifdef _WIN32
	Configuration& config = Configuration::get();

	cdefRoot->add(TE_TEXT("SOURCE"), _sourceFileName.string());

	te::ContextPtr context = te::Context::BuildContext();

	// Add root dictionary to context
	context->setDictionary(cdefRoot);

	// compile the template
	te::StringScanner reader(_template);
	te::TemplatePtr compiledTemplate = te::Template::parse(reader);

	te::te_converter utfConverter;
	std::string xmlManifest = utfConverter.to_bytes(compiledTemplate->render(context));

	// filename of the manifest file
	fs::path manifestFilePath(config.getManLocation());
	if (manifestFilePath.size() == 0) {
		manifestFilePath = _sourceFileName;
		manifestFilePath.replace_extension(".man");
	}

	// write the generated manifest file
	ofstream manifestStream;
	manifestStream.open(manifestFilePath.string());
	manifestStream << xmlManifest;
	manifestStream.close();

	// this check is made here in order to provide better error reporting.
	std::string pathToExe = findCtrppExe();
	if (pathToExe.size() == 0) {
		CompileMessage error(CompileMessage::type_t::Error, CdefMessage::CDE501, callback,
			"The CTRPP pre-processor tool could not be found");
		return false;
	}

	fs::path rcFilePath(config.getRcLocation());
	if (rcFilePath.size() == 0) {
		rcFilePath = _sourceFileName;
		rcFilePath.replace_extension(".rc");
	}

	fs::path hppFilePath(config.getHppLocation());
	if (hppFilePath.size() == 0) {
		hppFilePath = _sourceFileName;
		hppFilePath.replace_extension(".hpp");
	}

	// build command line parameters for ctrpp
	// typically something like -o %(DatName).hpp -rc %(DstName).rc %(SrcName)
	// parameters with embedded spaces must be enclosed in quotes
	std::stringstream parameters;
	parameters << "-o \"" << hppFilePath.string() << "\"";
	parameters << " -rc \"" << rcFilePath.replace_extension(".rc").string() << "\"";
	parameters << " \"" << manifestFilePath.string() << "\"";

	fs::path tempOutFile = fs::temp_directory_path() / fs::unique_path();
	fs::path tempErrFile = fs::temp_directory_path() / fs::unique_path();

	uint32_t errorCode = shellExecute(pathToExe, parameters.str(), tempOutFile.string(), tempErrFile.string());
	if (0 != errorCode) {
		CompileMessage error(CompileMessage::type_t::Error, CdefMessage::CDE502, callback,
			"The CTRPP pre-processor exited with an error code: '%d'", result);

		// copy the redirected console out into compile messages
		std::ifstream stdOutFile(tempOutFile.string());
		if (stdOutFile.is_open()) {
			std::string line;
			while (std::getline(stdOutFile, line)) {
				CompileMessage lineMessage(CompileMessage::type_t::Error, CdefMessage::CDE502, callback, line.c_str());
			}
		}
		stdOutFile.close();

		// copy the redirected console out into compile messages
		std::ifstream stdErrFile(tempErrFile.string());
		if (stdErrFile.is_open()) {
			std::string line;
			while (std::getline(stdErrFile, line)) {
				CompileMessage lineMessage(CompileMessage::type_t::Error, CdefMessage::CDE502, callback, line.c_str());
			}
		}
		stdErrFile.close();

		result = false;	// report an error
	}

	// cleanup the temp files
	fs::remove(tempOutFile);
	fs::remove(tempErrFile);

	if(!fs::exists(hppFilePath)) {
		CompileMessage error(CompileMessage::type_t::Error, CdefMessage::CDE503, callback,
			"CRTPP failed to create the required header file: '%s'", hppFilePath.string().c_str());
		result = false;
	}
	else if (!fs::exists(rcFilePath)) {
		CompileMessage error(CompileMessage::type_t::Error, CdefMessage::CDE504, callback,
			"CRTPP failed to create the required resource file: '%s'", rcFilePath.string().c_str());
		result = false;
	}

#endif

	return result;
}

}